"""
Report generation: Create RCA reports in markdown, JSON, and other formats.
"""

import json
from typing import Dict, Any
from datetime import datetime

from autorca_core.reasoning.loop import RCARunResult


def generate_markdown_report(result: RCARunResult) -> str:
    """
    Generate a markdown-formatted RCA report.

    Args:
        result: RCA run result

    Returns:
        Markdown-formatted report string
    """
    lines = []

    # Header
    lines.append("# Root Cause Analysis Report")
    lines.append("")
    lines.append(f"**Incident:** {result.primary_symptom}")
    lines.append(f"**Analysis Time:** {datetime.now().isoformat()}")
    lines.append(f"**Time Window:** {result.metadata.get('window_start', 'N/A')} to {result.metadata.get('window_end', 'N/A')}")
    lines.append("")
    lines.append("---")
    lines.append("")

    # Summary
    lines.append("## Executive Summary")
    lines.append("")
    lines.append(result.summary)
    lines.append("")
    lines.append("---")
    lines.append("")

    # Root Cause Candidates
    lines.append("## Root Cause Analysis")
    lines.append("")

    if not result.root_cause_candidates:
        lines.append("No root cause candidates identified.")
    else:
        for i, candidate in enumerate(result.root_cause_candidates[:5], 1):  # Show top 5
            lines.append(f"### {i}. {candidate.service} ({candidate.incident_type.value})")
            lines.append("")
            lines.append(f"**Confidence:** {candidate.confidence:.0%}")
            lines.append("")
            lines.append(f"**Explanation:** {candidate.explanation}")
            lines.append("")

            if candidate.evidence:
                lines.append("**Evidence:**")
                for evidence in candidate.evidence[:5]:  # Show first 5 pieces of evidence
                    lines.append(f"- {evidence}")
                lines.append("")

            if candidate.remediation:
                lines.append("**Recommended Actions:**")
                for j, action in enumerate(candidate.remediation, 1):
                    lines.append(f"{j}. {action}")
                lines.append("")

    lines.append("---")
    lines.append("")

    # Incident Timeline
    lines.append("## Incident Timeline")
    lines.append("")

    if not result.timeline:
        lines.append("No incidents detected in the analysis window.")
    else:
        lines.append("| Time | Service | Type | Description | Severity |")
        lines.append("|------|---------|------|-------------|----------|")

        for incident in result.timeline:
            timestamp = incident['timestamp'][:19]  # Truncate to seconds
            service = incident['service']
            incident_type = incident['type']
            description = incident['description'][:50]  # Truncate long descriptions
            severity = f"{incident['severity']:.2f}"

            lines.append(f"| {timestamp} | {service} | {incident_type} | {description} | {severity} |")

    lines.append("")
    lines.append("---")
    lines.append("")

    # Service Graph Overview
    lines.append("## Service Graph")
    lines.append("")
    lines.append(f"**Services:** {result.metadata.get('num_services', 0)}")
    lines.append(f"**Dependencies:** {result.metadata.get('num_dependencies', 0)}")
    lines.append(f"**Incidents:** {result.metadata.get('num_incidents', 0)}")
    lines.append("")

    # List services with incidents
    if result.service_graph.incidents:
        services_with_incidents = sorted(set(i.service for i in result.service_graph.incidents))
        lines.append("**Services with Incidents:**")
        for service in services_with_incidents:
            incident_count = len([i for i in result.service_graph.incidents if i.service == service])
            lines.append(f"- {service} ({incident_count} incident{'s' if incident_count > 1 else ''})")
        lines.append("")

    lines.append("---")
    lines.append("")

    # Data Sources
    lines.append("## Data Sources")
    lines.append("")
    lines.append(f"- **Logs:** {result.metadata.get('num_logs', 0)} events")
    lines.append(f"- **Metrics:** {result.metadata.get('num_metrics', 0)} data points")
    lines.append(f"- **Traces:** {result.metadata.get('num_traces', 0)} spans")
    lines.append(f"- **Config Changes:** {result.metadata.get('num_configs', 0)} changes")
    lines.append("")

    # Footer
    lines.append("---")
    lines.append("")
    lines.append("*Report generated by AutoRCA-Core (ADAPT-RCA)*")
    lines.append("")

    return "\n".join(lines)


def generate_json_report(result: RCARunResult, indent: int = 2) -> str:
    """
    Generate a JSON-formatted RCA report.

    Args:
        result: RCA run result
        indent: JSON indentation (default: 2)

    Returns:
        JSON-formatted report string
    """
    report = result.to_dict()

    # Add timestamp
    report['generated_at'] = datetime.now().isoformat()

    return json.dumps(report, indent=indent, default=str)


def generate_html_report(result: RCARunResult) -> str:
    """
    Generate an HTML-formatted RCA report.

    TODO: Implement HTML report generation with charts and visualizations.

    Args:
        result: RCA run result

    Returns:
        HTML-formatted report string
    """
    # For now, convert markdown to basic HTML
    markdown = generate_markdown_report(result)

    html_parts = [
        "<!DOCTYPE html>",
        "<html>",
        "<head>",
        "  <meta charset='UTF-8'>",
        "  <title>RCA Report - AutoRCA-Core</title>",
        "  <style>",
        "    body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }",
        "    h1 { color: #2c3e50; border-bottom: 2px solid #3498db; }",
        "    h2 { color: #34495e; margin-top: 30px; }",
        "    h3 { color: #7f8c8d; }",
        "    table { border-collapse: collapse; width: 100%; margin: 20px 0; }",
        "    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }",
        "    th { background-color: #3498db; color: white; }",
        "    code { background-color: #f4f4f4; padding: 2px 6px; border-radius: 3px; }",
        "    .confidence { font-weight: bold; color: #27ae60; }",
        "    .evidence { background-color: #ecf0f1; padding: 10px; margin: 10px 0; border-left: 4px solid #3498db; }",
        "  </style>",
        "</head>",
        "<body>",
        "  <pre style='white-space: pre-wrap;'>",
        markdown,
        "  </pre>",
        "</body>",
        "</html>",
    ]

    return "\n".join(html_parts)


def save_report(result: RCARunResult, output_path: str, format: str = "markdown") -> None:
    """
    Save RCA report to a file.

    Args:
        result: RCA run result
        output_path: Path to save the report
        format: Report format ("markdown", "json", "html")
    """
    if format == "markdown" or format == "md":
        content = generate_markdown_report(result)
    elif format == "json":
        content = generate_json_report(result)
    elif format == "html":
        content = generate_html_report(result)
    else:
        raise ValueError(f"Unsupported format: {format}. Use 'markdown', 'json', or 'html'.")

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)

    print(f"Report saved to: {output_path}")
